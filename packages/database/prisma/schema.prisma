// NarrativeForge Database Schema
// PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Wallet authentication
  walletAddress String   @unique
  nonce         String?  // For signature verification
  
  // Profile
  username      String?  @unique
  bio           String?
  avatar        String?
  
  // Stats
  totalBets     Int      @default(0)
  totalWon      Decimal  @default(0) @db.Decimal(20, 6)
  totalLost     Decimal  @default(0) @db.Decimal(20, 6)
  winRate       Float    @default(0) // Percentage
  
  // Streaks & Achievements
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastBetDate   DateTime?
  
  // Relationships
  bets          Bet[]
  createdStories Story[] @relation("StoryAuthor")
  badges        UserBadge[]
  notifications Notification[]
  notificationPreference NotificationPreference?
  playerSkill   PlayerSkill?
  
  @@index([walletAddress])
  @@map("users")
}

// ============================================================================
// DYNAMIC DIFFICULTY BETTING (Skill-Based Matchmaking)
// ============================================================================

model PlayerSkill {
  id              String   @id @default(cuid())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  userId          String   @unique
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // ELO Rating (1000-3000)
  eloRating       Int      @default(1000)
  
  // Betting stats
  totalBets       Int      @default(0)
  wins            Int      @default(0)
  losses          Int      @default(0)
  winRate         Float    @default(0) // 0-1
  
  // Streaks
  currentStreak   Int      @default(0) // Positive = wins, negative = losses
  longestWinStreak Int     @default(0)
  
  // Skill tier (NOVICE, INTERMEDIATE, EXPERT, MASTER, LEGEND)
  tier            String   @default("NOVICE")
  
  // Financial stats
  lastBetDate     DateTime @default(now())
  averageBetSize  Decimal  @default(0) @db.Decimal(20, 6)
  totalWagered    Decimal  @default(0) @db.Decimal(20, 6)
  totalEarnings   Decimal  @default(0) @db.Decimal(20, 6)
  netProfit       Decimal  @default(0) @db.Decimal(20, 6)
  
  // Tier history (for tracking progression)
  tierHistory     Json     @default("[]")
  // Format: [{ tier: "NOVICE", achievedAt: "2026-02-15T..." }]
  
  @@index([tier])
  @@index([eloRating])
  @@map("player_skills")
}

// ============================================================================
// STORIES & CHAPTERS
// ============================================================================

model Story {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Metadata
  title         String
  description   String
  genre         String   // Sci-Fi, Fantasy, Cyberpunk, etc.
  coverImage    String?
  
  // Status
  status        StoryStatus @default(ACTIVE)
  currentChapter Int      @default(1)
  totalChapters Int      @default(0)
  
  // Author (can be AI or human)
  authorId      String
  author        User     @relation("StoryAuthor", fields: [authorId], references: [id])
  isAIGenerated Boolean  @default(true)
  
  // Stats
  totalReaders  Int      @default(0)
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  viewCount     Int      @default(0)
  
  // Relationships
  chapters      Chapter[]
  characters    Character[]
  
  @@index([status, createdAt])
  @@index([genre])
  @@map("stories")
}

enum StoryStatus {
  ACTIVE      // Currently accepting bets
  PAUSED      // Temporarily paused
  COMPLETED   // Story finished
  ARCHIVED    // No longer active
}

model Chapter {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Chapter info
  storyId       String
  story         Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  chapterNumber Int
  
  // Content
  title         String
  content       String   @db.Text
  summary       String?  @db.Text
  
  // Images (AI-generated or uploaded)
  headerImage   String?
  images        String[] // Array of image URLs
  
  // Metadata
  wordCount     Int      @default(0)
  readTime      Int      @default(0) // Minutes
  
  // Status
  status        ChapterStatus @default(DRAFT)
  publishedAt   DateTime?
  
  // AI Generation metadata
  aiModel       String?  // GPT-4, Claude, etc.
  aiPrompt      String?  @db.Text
  generationTime Int?    // Milliseconds
  
  // Relationships
  choices       Choice[]
  bettingPool   BettingPool?
  
  @@unique([storyId, chapterNumber])
  @@index([storyId, chapterNumber])
  @@map("chapters")
}

enum ChapterStatus {
  DRAFT       // Being written/generated
  PUBLISHED   // Live and readable
  BETTING     // Betting pool active for next chapter
  RESOLVED    // AI made choice, betting resolved
  ARCHIVED    // No longer active
}

// ============================================================================
// CHOICES & BETTING
// ============================================================================

model Choice {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Choice info
  chapterId     String
  chapter       Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  choiceNumber  Int      // 1, 2, 3, etc.
  
  // Content
  text          String   @db.Text
  description   String?  @db.Text
  
  // Outcome (after AI chooses)
  isChosen      Boolean  @default(false)
  chosenAt      DateTime?
  
  // AI Analysis
  aiScore       Float?   // 0-100, AI's preference score
  aiReasoning   String?  @db.Text
  
  // Stats
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  betCount      Int      @default(0)
  oddsSnapshot  Float?   // Odds at close time
  
  // Relationships
  bets          Bet[]
  
  @@unique([chapterId, choiceNumber])
  @@index([chapterId])
  @@map("choices")
}

model BettingPool {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Pool info
  chapterId     String   @unique
  chapter       Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  
  // Pool settings
  betToken      String   @default("USDC") // USDC or USDT
  betTokenAddress String // ERC20 contract address
  minBet        Decimal  @default(10) @db.Decimal(20, 6) // $10 USDC
  maxBet        Decimal? @default(10000) @db.Decimal(20, 6) // $10,000 USDC
  
  // Timing
  opensAt       DateTime
  closesAt      DateTime
  resolvedAt    DateTime?
  
  // Status
  status        PoolStatus @default(PENDING)
  
  // Pool totals
  totalPool     Decimal  @default(0) @db.Decimal(20, 6)
  totalBets     Int      @default(0)
  uniqueBettors Int      @default(0)
  
  // Smart contract
  contractAddress String?
  contractTxHash  String?
  
  // Winner info (after resolution)
  winningChoiceId String?
  winnersPaid     Decimal  @default(0) @db.Decimal(20, 6)
  treasuryCut     Decimal  @default(0) @db.Decimal(20, 6)
  devCut          Decimal  @default(0) @db.Decimal(20, 6)
  
  // Relationships
  bets          Bet[]
  oddsSnapshots OddsSnapshot[]
  
  @@index([status, closesAt])
  @@map("betting_pools")
}

enum PoolStatus {
  PENDING     // Not yet open
  OPEN        // Accepting bets
  CLOSED      // No more bets, waiting for AI
  RESOLVING   // AI is deciding
  RESOLVED    // Winner chosen
  CANCELLED   // Pool cancelled (refunds)
}

model Bet {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Bettor
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  
  // Bet details
  poolId        String
  pool          BettingPool @relation(fields: [poolId], references: [id])
  
  choiceId      String
  choice        Choice   @relation(fields: [choiceId], references: [id])
  
  // Amount
  amount        Decimal  @db.Decimal(20, 6)
  
  // Outcome
  isWinner      Boolean  @default(false)
  payout        Decimal? @db.Decimal(20, 6)
  payoutTxHash  String?
  
  // Metadata
  odds          Float?   // Odds at time of bet
  txHash        String?  // Blockchain transaction hash
  
  @@index([userId])
  @@index([poolId])
  @@index([choiceId])
  @@map("bets")
}

// ============================================================================
// AI GENERATION & ANALYTICS
// ============================================================================

model AIGeneration {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())

  // Generation type
  type          GenerationType
  
  // Reference
  entityId      String   // Story, Chapter, or Choice ID
  entityType    String   // "story", "chapter", "choice"
  
  // AI Model
  model         String   // GPT-4, Claude-3, DALL-E, etc.
  provider      String   // OpenAI, Anthropic, etc.
  
  // Prompt & Response
  prompt        String   @db.Text
  response      String   @db.Text
  
  // Metadata
  tokensUsed    Int?
  cost          Decimal? @db.Decimal(10, 6)
  latency       Int?     // Milliseconds
  
  // Success/Error
  status        String   // success, error, partial
  error         String?  @db.Text
  
  @@index([entityId, entityType])
  @@index([createdAt])
  @@map("ai_generations")
}

enum GenerationType {
  STORY_CONCEPT   // Initial story idea
  CHAPTER_CONTENT // Chapter text
  CHOICE_OPTIONS  // Multiple choice options
  AI_DECISION     // AI choosing winning path
  IMAGE           // Image generation
  SUMMARY         // Content summarization
}

model Analytics {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  date          DateTime @unique @db.Date

  // Daily metrics
  activeUsers   Int      @default(0)
  newUsers      Int      @default(0)
  
  // Story metrics
  storiesCreated Int     @default(0)
  chaptersPublished Int  @default(0)
  
  // Betting metrics
  totalBets     Int      @default(0)
  totalVolume   Decimal  @default(0) @db.Decimal(20, 6)
  uniqueBettors Int      @default(0)
  
  // Revenue
  platformFees  Decimal  @default(0) @db.Decimal(20, 6)
  tradingFees   Decimal  @default(0) @db.Decimal(20, 6)
  
  // AI usage
  aiCalls       Int      @default(0)
  aiCost        Decimal  @default(0) @db.Decimal(10, 6)
  
  @@index([date])
  @@map("analytics")
}

// ============================================================================
// BADGES & ACHIEVEMENTS
// ============================================================================

model Badge {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  // Badge info
  name          String   @unique
  description   String
  icon          String   // Emoji or image URL
  rarity        BadgeRarity
  
  // Unlock criteria
  criteriaType  CriteriaType
  criteriaValue Int?
  
  // Relationships
  userBadges    UserBadge[]
  
  @@map("badges")
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum CriteriaType {
  WINS       // X winning bets
  STREAK     // X wins in a row
  PROFIT     // $X total profit
  VOLUME     // $X total wagered
  BETS       // X total bets
  SPECIAL    // Manual/event-based
}

model UserBadge {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  badgeId       String
  badge         Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  earnedAt      DateTime @default(now())
  
  @@unique([userId, badgeId])
  @@index([userId])
  @@index([badgeId])
  @@map("user_badges")
}

// ============================================================================
// ODDS TRACKING (Real-Time Betting Odds Dashboard)
// ============================================================================

model OddsSnapshot {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  poolId        String
  pool          BettingPool @relation(fields: [poolId], references: [id], onDelete: Cascade)
  
  // Snapshot data (JSON to store odds for all choices)
  // Format: { "choice_id_1": 0.65, "choice_id_2": 0.35 }
  choiceOdds    Json
  
  // Pool state at snapshot time
  totalPool     Decimal  @db.Decimal(20, 6)
  totalBets     Int
  uniqueBettors Int
  
  @@index([poolId, createdAt])
  @@map("odds_snapshots")
}

// ============================================================================
// CHARACTER MEMORY SYSTEM (Story Universe Continuity)
// ============================================================================

model Character {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  storyId       String
  story         Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  
  // Profile
  name          String
  description   String   @db.Text
  portrait      String?  // AI-generated image URL
  
  // AI-tracked traits (JSON)
  // Format: { "brave": 0.8, "cautious": 0.2, "loyal": 0.9 }
  traits        Json     @default("{}")
  
  // Appearance tracking
  firstAppearance Int    // Chapter number
  lastAppearance  Int    // Chapter number
  totalAppearances Int   @default(0)
  
  // Relationships
  memories      CharacterMemory[]
  relationships CharacterRelationship[] @relation("CharacterA")
  relatedTo     CharacterRelationship[] @relation("CharacterB")
  
  @@unique([storyId, name])
  @@index([storyId])
  @@map("characters")
}

model CharacterMemory {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  characterId   String
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  chapterId     String
  choiceId      String?  // Winning choice that created this memory
  
  // Memory content
  eventType     MemoryType
  description   String   @db.Text
  emotionalImpact Float  // -1.0 (traumatic) to +1.0 (joyful)
  importance    Int      // 1-10 (how much this shapes character)
  
  @@index([characterId])
  @@index([chapterId])
  @@map("character_memories")
}

enum MemoryType {
  DECISION       // Character made a choice
  RELATIONSHIP   // Interaction with another character
  REVELATION     // Learned something important
  TRAUMA         // Negative event
  ACHIEVEMENT    // Positive accomplishment
}

model CharacterRelationship {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  characterAId  String
  characterA    Character @relation("CharacterA", fields: [characterAId], references: [id], onDelete: Cascade)
  
  characterBId  String
  characterB    Character @relation("CharacterB", fields: [characterBId], references: [id], onDelete: Cascade)
  
  // Relationship score: -1.0 (enemies) to +1.0 (best friends)
  score         Float    @default(0)
  relationshipType RelationType
  
  // How this evolved
  history       Json     @default("[]")
  // Format: [{ chapter: 3, event: "Sarah saved Marcus", delta: +0.3 }]
  
  @@unique([characterAId, characterBId])
  @@index([characterAId])
  @@index([characterBId])
  @@map("character_relationships")
}

enum RelationType {
  FAMILY
  FRIEND
  ROMANTIC
  RIVAL
  MENTOR
  ENEMY
  ALLY
  NEUTRAL
}

model AlternateOutcome {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  chapterId     String
  choiceId      String   // The choice that DIDN'T win
  
  // AI-generated preview
  preview       String   @db.Text
  fullContent   String?  @db.Text // Optional: full alternate chapter
  
  // Metadata
  aiModel       String
  generated     Boolean  @default(false)
  viewCount     Int      @default(0)
  
  @@unique([chapterId, choiceId])
  @@index([chapterId])
  @@map("alternate_outcomes")
}

// ============================================================================
// NOTIFICATIONS (Smart Notification System)
// ============================================================================

model Notification {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Notification details
  type          NotificationType
  title         String
  message       String   @db.Text
  link          String?  // Deep link to relevant page
  
  // Read status
  isRead        Boolean  @default(false)
  readAt        DateTime?
  
  // Optional metadata (bet details, story info, etc.)
  metadata      Json?
  
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

enum NotificationType {
  CHAPTER_RELEASED  // New chapter published
  BET_WON           // Your bet won
  BET_LOST          // Your bet lost
  STREAK_MILESTONE  // Win streak achieved
  LEADERBOARD       // Leaderboard position change
  FRIEND_ACTIVITY   // Friend bet or won
  WEEKLY_DIGEST     // Weekly performance summary
  POOL_CLOSING      // Pool closing soon
  SYSTEM            // System announcements
}

model NotificationPreference {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Channel preferences
  pushEnabled   Boolean  @default(true)
  emailEnabled  Boolean  @default(true)
  inAppEnabled  Boolean  @default(true)
  
  // Notification type preferences
  chapterReleases Boolean @default(true)
  betOutcomes     Boolean @default(true)
  streaks         Boolean @default(true)
  leaderboard     Boolean @default(false)
  friendActivity  Boolean @default(true)
  weeklyDigest    Boolean @default(true)
  poolClosing     Boolean @default(true)
  system          Boolean @default(true)
  
  @@map("notification_preferences")
}
