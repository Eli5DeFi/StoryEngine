// NarrativeForge Database Schema
// PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Wallet authentication
  walletAddress String   @unique
  nonce         String?  // For signature verification
  
  // Profile
  username      String?  @unique
  bio           String?
  avatar        String?
  
  // Stats
  totalBets     Int      @default(0)
  totalWon      Decimal  @default(0) @db.Decimal(20, 6)
  totalLost     Decimal  @default(0) @db.Decimal(20, 6)
  winRate       Float    @default(0) // Percentage
  
  // Streaks & Achievements
  currentStreak Int      @default(0)
  longestStreak Int      @default(0)
  lastBetDate   DateTime?
  
  // Relationships
  bets          Bet[]
  createdStories Story[] @relation("StoryAuthor")
  badges        UserBadge[]
  notifications Notification[]
  notificationPreference NotificationPreference?
  userHouses    UserHouse[] // House affiliations
  characterHoldings CharacterHolder[] // Character SBTs owned
  
  @@index([walletAddress])
  @@map("users")
}

// ============================================================================
// STORIES & CHAPTERS
// ============================================================================

model Story {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Metadata
  title         String
  description   String
  genre         String   // Sci-Fi, Fantasy, Cyberpunk, etc.
  coverImage    String?
  
  // Status
  status        StoryStatus @default(ACTIVE)
  currentChapter Int      @default(1)
  totalChapters Int      @default(0)
  
  // Author (can be AI or human)
  authorId      String
  author        User     @relation("StoryAuthor", fields: [authorId], references: [id])
  isAIGenerated Boolean  @default(true)
  
  // Stats
  totalReaders  Int      @default(0)
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  viewCount     Int      @default(0)
  
  // Relationships
  chapters      Chapter[]
  characters    Character[]
  
  @@index([status, createdAt])
  @@index([genre])
  @@map("stories")
}

enum StoryStatus {
  ACTIVE      // Currently accepting bets
  PAUSED      // Temporarily paused
  COMPLETED   // Story finished
  ARCHIVED    // No longer active
}

model Chapter {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Chapter info
  storyId       String
  story         Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  chapterNumber Int
  
  // Content
  title         String
  content       String   @db.Text
  summary       String?  @db.Text
  
  // Images (AI-generated or uploaded)
  headerImage   String?
  images        String[] // Array of image URLs
  
  // Metadata
  wordCount     Int      @default(0)
  readTime      Int      @default(0) // Minutes
  
  // Status
  status        ChapterStatus @default(DRAFT)
  publishedAt   DateTime?
  
  // AI Generation metadata
  aiModel       String?  // GPT-4, Claude, etc.
  aiPrompt      String?  @db.Text
  generationTime Int?    // Milliseconds
  
  // Relationships
  choices       Choice[]
  bettingPool   BettingPool?
  characterAppearances CharacterSBTAppearance[] // SBT revenue distributions
  
  @@unique([storyId, chapterNumber])
  @@index([storyId, chapterNumber])
  @@map("chapters")
}

enum ChapterStatus {
  DRAFT       // Being written/generated
  PUBLISHED   // Live and readable
  BETTING     // Betting pool active for next chapter
  RESOLVED    // AI made choice, betting resolved
  ARCHIVED    // No longer active
}

// ============================================================================
// CHOICES & BETTING
// ============================================================================

model Choice {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Choice info
  chapterId     String
  chapter       Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  choiceNumber  Int      // 1, 2, 3, etc.
  
  // Content
  text          String   @db.Text
  description   String?  @db.Text
  
  // Outcome (after AI chooses)
  isChosen      Boolean  @default(false)
  chosenAt      DateTime?
  
  // AI Analysis
  aiScore       Float?   // 0-100, AI's preference score
  aiReasoning   String?  @db.Text
  
  // Stats
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  betCount      Int      @default(0)
  oddsSnapshot  Float?   // Odds at close time
  
  // Relationships
  bets          Bet[]
  
  @@unique([chapterId, choiceNumber])
  @@index([chapterId])
  @@map("choices")
}

model BettingPool {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Pool info
  chapterId     String   @unique
  chapter       Chapter  @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  
  // Pool settings
  betToken      String   @default("USDC") // USDC or USDT
  betTokenAddress String // ERC20 contract address
  minBet        Decimal  @default(10) @db.Decimal(20, 6) // $10 USDC
  maxBet        Decimal? @default(10000) @db.Decimal(20, 6) // $10,000 USDC
  
  // Timing
  opensAt       DateTime
  closesAt      DateTime
  resolvedAt    DateTime?
  
  // Status
  status        PoolStatus @default(PENDING)
  
  // Pool totals
  totalPool     Decimal  @default(0) @db.Decimal(20, 6)
  totalBets     Int      @default(0)
  uniqueBettors Int      @default(0)
  
  // Smart contract
  contractAddress String?
  contractTxHash  String?
  
  // Winner info (after resolution)
  winningChoiceId String?
  winnersPaid     Decimal  @default(0) @db.Decimal(20, 6)
  treasuryCut     Decimal  @default(0) @db.Decimal(20, 6)
  devCut          Decimal  @default(0) @db.Decimal(20, 6)
  
  // Relationships
  bets          Bet[]
  oddsSnapshots OddsSnapshot[]
  
  @@index([status, closesAt])
  @@map("betting_pools")
}

enum PoolStatus {
  PENDING     // Not yet open
  OPEN        // Accepting bets
  CLOSED      // No more bets, waiting for AI
  RESOLVING   // AI is deciding
  RESOLVED    // Winner chosen
  CANCELLED   // Pool cancelled (refunds)
}

model Bet {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Bettor
  userId        String
  user          User     @relation(fields: [userId], references: [id])
  
  // Bet details
  poolId        String
  pool          BettingPool @relation(fields: [poolId], references: [id])
  
  choiceId      String
  choice        Choice   @relation(fields: [choiceId], references: [id])
  
  // Amount
  amount        Decimal  @db.Decimal(20, 6)
  
  // Outcome
  isWinner      Boolean  @default(false)
  payout        Decimal? @db.Decimal(20, 6)
  payoutTxHash  String?
  
  // Metadata
  odds          Float?   // Odds at time of bet
  txHash        String?  // Blockchain transaction hash
  
  @@index([userId])
  @@index([poolId])
  @@index([choiceId])
  @@map("bets")
}

// ============================================================================
// AI GENERATION & ANALYTICS
// ============================================================================

model AIGeneration {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())

  // Generation type
  type          GenerationType
  
  // Reference
  entityId      String   // Story, Chapter, or Choice ID
  entityType    String   // "story", "chapter", "choice"
  
  // AI Model
  model         String   // GPT-4, Claude-3, DALL-E, etc.
  provider      String   // OpenAI, Anthropic, etc.
  
  // Prompt & Response
  prompt        String   @db.Text
  response      String   @db.Text
  
  // Metadata
  tokensUsed    Int?
  cost          Decimal? @db.Decimal(10, 6)
  latency       Int?     // Milliseconds
  
  // Success/Error
  status        String   // success, error, partial
  error         String?  @db.Text
  
  @@index([entityId, entityType])
  @@index([createdAt])
  @@map("ai_generations")
}

enum GenerationType {
  STORY_CONCEPT   // Initial story idea
  CHAPTER_CONTENT // Chapter text
  CHOICE_OPTIONS  // Multiple choice options
  AI_DECISION     // AI choosing winning path
  IMAGE           // Image generation
  SUMMARY         // Content summarization
}

model Analytics {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  date          DateTime @unique @db.Date

  // Daily metrics
  activeUsers   Int      @default(0)
  newUsers      Int      @default(0)
  
  // Story metrics
  storiesCreated Int     @default(0)
  chaptersPublished Int  @default(0)
  
  // Betting metrics
  totalBets     Int      @default(0)
  totalVolume   Decimal  @default(0) @db.Decimal(20, 6)
  uniqueBettors Int      @default(0)
  
  // Revenue
  platformFees  Decimal  @default(0) @db.Decimal(20, 6)
  tradingFees   Decimal  @default(0) @db.Decimal(20, 6)
  
  // AI usage
  aiCalls       Int      @default(0)
  aiCost        Decimal  @default(0) @db.Decimal(10, 6)
  
  @@index([date])
  @@map("analytics")
}

// ============================================================================
// BADGES & ACHIEVEMENTS
// ============================================================================

model Badge {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  // Badge info
  name          String   @unique
  description   String
  icon          String   // Emoji or image URL
  rarity        BadgeRarity
  
  // Unlock criteria
  criteriaType  CriteriaType
  criteriaValue Int?
  
  // Relationships
  userBadges    UserBadge[]
  
  @@map("badges")
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum CriteriaType {
  WINS       // X winning bets
  STREAK     // X wins in a row
  PROFIT     // $X total profit
  VOLUME     // $X total wagered
  BETS       // X total bets
  SPECIAL    // Manual/event-based
}

model UserBadge {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  badgeId       String
  badge         Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  
  earnedAt      DateTime @default(now())
  
  @@unique([userId, badgeId])
  @@index([userId])
  @@index([badgeId])
  @@map("user_badges")
}

// ============================================================================
// ODDS TRACKING (Real-Time Betting Odds Dashboard)
// ============================================================================

model OddsSnapshot {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  poolId        String
  pool          BettingPool @relation(fields: [poolId], references: [id], onDelete: Cascade)
  
  // Snapshot data (JSON to store odds for all choices)
  // Format: { "choice_id_1": 0.65, "choice_id_2": 0.35 }
  choiceOdds    Json
  
  // Pool state at snapshot time
  totalPool     Decimal  @db.Decimal(20, 6)
  totalBets     Int
  uniqueBettors Int
  
  @@index([poolId, createdAt])
  @@map("odds_snapshots")
}

// ============================================================================
// CHARACTER MEMORY SYSTEM (Story Universe Continuity)
// ============================================================================

model Character {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  storyId       String
  story         Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  
  // Profile
  name          String
  description   String   @db.Text
  portrait      String?  // AI-generated image URL
  
  // AI-tracked traits (JSON)
  // Format: { "brave": 0.8, "cautious": 0.2, "loyal": 0.9 }
  traits        Json     @default("{}")
  
  // Appearance tracking
  firstAppearance Int    // Chapter number
  lastAppearance  Int    // Chapter number
  totalAppearances Int   @default(0)
  
  // Relationships
  memories      CharacterMemory[]
  relationships CharacterRelationship[] @relation("CharacterA")
  relatedTo     CharacterRelationship[] @relation("CharacterB")
  sbt           CharacterSBT? // Soul-Bound Token (if mintable)
  
  @@unique([storyId, name])
  @@index([storyId])
  @@map("characters")
}

model CharacterMemory {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  characterId   String
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  chapterId     String
  choiceId      String?  // Winning choice that created this memory
  
  // Memory content
  eventType     MemoryType
  description   String   @db.Text
  emotionalImpact Float  // -1.0 (traumatic) to +1.0 (joyful)
  importance    Int      // 1-10 (how much this shapes character)
  
  @@index([characterId])
  @@index([chapterId])
  @@map("character_memories")
}

enum MemoryType {
  DECISION       // Character made a choice
  RELATIONSHIP   // Interaction with another character
  REVELATION     // Learned something important
  TRAUMA         // Negative event
  ACHIEVEMENT    // Positive accomplishment
}

model CharacterRelationship {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  characterAId  String
  characterA    Character @relation("CharacterA", fields: [characterAId], references: [id], onDelete: Cascade)
  
  characterBId  String
  characterB    Character @relation("CharacterB", fields: [characterBId], references: [id], onDelete: Cascade)
  
  // Relationship score: -1.0 (enemies) to +1.0 (best friends)
  score         Float    @default(0)
  relationshipType RelationType
  
  // How this evolved
  history       Json     @default("[]")
  // Format: [{ chapter: 3, event: "Sarah saved Marcus", delta: +0.3 }]
  
  @@unique([characterAId, characterBId])
  @@index([characterAId])
  @@index([characterBId])
  @@map("character_relationships")
}

enum RelationType {
  FAMILY
  FRIEND
  ROMANTIC
  RIVAL
  MENTOR
  ENEMY
  ALLY
  NEUTRAL
}

model AlternateOutcome {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  chapterId     String
  choiceId      String   // The choice that DIDN'T win
  
  // AI-generated preview
  preview       String   @db.Text
  fullContent   String?  @db.Text // Optional: full alternate chapter
  
  // Metadata
  aiModel       String
  generated     Boolean  @default(false)
  viewCount     Int      @default(0)
  
  @@unique([chapterId, choiceId])
  @@index([chapterId])
  @@map("alternate_outcomes")
}

// ============================================================================
// VOIDBORNE LORE SYSTEM (Houses, Protocols, Characters)
// ============================================================================

model House {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Identity
  slug          String   @unique // valdris, meridian, thuun, proof, drift, weave, null
  name          String   @unique
  description   String   @db.Text
  lore          String   @db.Text // Full lore content (markdown)
  
  // Visual Identity
  primaryColor  String   // Hex color (#00ff41)
  secondaryColor String?
  icon          String?  // Icon URL or emoji
  bannerImage   String?  // Header image
  
  // Strand Affiliation
  strandType    String   // G (Gravity), L (Lattice), S (Stitch), R (Radiance), C (Code), Ø (Null)
  strandDescription String @db.Text
  
  // Territory & Power
  territory     String?
  population    Int?
  influence     Int      @default(500) // 0-1000 power scale
  
  // Game Mechanics
  reputation    Int      @default(500) // Base house reputation
  totalMembers  Int      @default(0)
  
  // Stats
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  totalWins     Int      @default(0)
  winRate       Float    @default(0)
  
  // Relations
  protocols     Protocol[]
  userHouses    UserHouse[]
  
  @@index([slug])
  @@index([strandType])
  @@map("houses")
}

model Protocol {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Identity
  slug          String   @unique // stellar-return, null-genesis, etc.
  code          String   @unique // SR-01, NL-∅, etc.
  name          String
  description   String   @db.Text
  lore          String   @db.Text // Full lore content (markdown)
  
  // House Affiliation
  houseId       String
  house         House    @relation(fields: [houseId], references: [id], onDelete: Cascade)
  
  // Technical Specs
  strandType    String   // Primary Strand (G, L, S, R, C, Ø)
  spectrum      String   // HARD (military), SOFT (civilian), HYBRID
  orderRange    String   // "7-9", "4-6", "1-3", etc.
  
  // Mechanics
  cost          String   @db.Text // Energy cost, requirements
  effects       String   @db.Text // What it does
  risks         String?  @db.Text // Dangers, side effects
  
  // Rarity & Power
  rarity        ProtocolRarity @default(COMMON)
  powerLevel    Int      @default(5) // 1-10 scale
  
  // Usage Stats (for game mechanics)
  timesUsed     Int      @default(0)
  successRate   Float    @default(0)
  
  // Visual
  icon          String?
  color         String?  // Hex color
  
  @@index([houseId])
  @@index([strandType])
  @@index([spectrum])
  @@index([rarity])
  @@map("protocols")
}

enum ProtocolRarity {
  COMMON        // Basic protocols
  UNCOMMON      // Specialized
  RARE          // Advanced
  EPIC          // Powerful
  LEGENDARY     // Forbidden/Lost
}

model UserHouse {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Relations
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  houseId       String
  house         House    @relation(fields: [houseId], references: [id], onDelete: Cascade)
  
  // Status
  isPrimary     Boolean  @default(false) // Primary house affiliation
  joinedAt      DateTime @default(now())
  
  // Progression
  reputation    Int      @default(0) // House-specific reputation
  rank          String   @default("Initiate")
  level         Int      @default(1)
  experience    Int      @default(0)
  
  // Contributions
  totalBets     Decimal  @default(0) @db.Decimal(20, 6)
  totalWins     Int      @default(0)
  protocolsLearned String[] // Protocol IDs
  
  // Achievements
  badges        String[] // House-specific badges
  title         String?  // Honorary title
  
  @@unique([userId, houseId])
  @@index([userId])
  @@index([houseId])
  @@index([reputation])
  @@map("user_houses")
}

// ============================================================================
// NOTIFICATIONS (Smart Notification System)
// ============================================================================

model Notification {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Notification details
  type          NotificationType
  title         String
  message       String   @db.Text
  link          String?  // Deep link to relevant page
  
  // Read status
  isRead        Boolean  @default(false)
  readAt        DateTime?
  
  // Optional metadata (bet details, story info, etc.)
  metadata      Json?
  
  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

enum NotificationType {
  CHAPTER_RELEASED  // New chapter published
  BET_WON           // Your bet won
  BET_LOST          // Your bet lost
  STREAK_MILESTONE  // Win streak achieved
  LEADERBOARD       // Leaderboard position change
  FRIEND_ACTIVITY   // Friend bet or won
  WEEKLY_DIGEST     // Weekly performance summary
  POOL_CLOSING      // Pool closing soon
  SYSTEM            // System announcements
}

model NotificationPreference {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  userId        String   @unique
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Channel preferences
  pushEnabled   Boolean  @default(true)
  emailEnabled  Boolean  @default(true)
  inAppEnabled  Boolean  @default(true)
  
  // Notification type preferences
  chapterReleases Boolean @default(true)
  betOutcomes     Boolean @default(true)
  streaks         Boolean @default(true)
  leaderboard     Boolean @default(false)
  friendActivity  Boolean @default(true)
  weeklyDigest    Boolean @default(true)
  poolClosing     Boolean @default(true)
  system          Boolean @default(true)
  
  @@map("notification_preferences")
}

// ============================================================================
// CHARACTER SOUL-BOUND TOKENS (Innovation Cycle #44)
// ============================================================================

model CharacterSBT {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Reference to story character
  characterId   String   @unique
  character     Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  // Blockchain data
  contractAddress String?
  onChainId     Int?     @unique // Character ID on smart contract
  
  // SBT Configuration
  maxSupply     Int      @default(100)
  mintPrice     Decimal  @default(0.05) @db.Decimal(20, 6) // ETH
  mintingOpen   Boolean  @default(true)
  
  // Stats
  totalSupply   Int      @default(0) // Current holders
  totalEarnings Decimal  @default(0) @db.Decimal(20, 6) // USDC distributed
  
  // Leveling
  xp            Int      @default(0) // Appearances
  level         Int      @default(1) // 1 + (xp / 5)
  
  // Status
  isAlive       Boolean  @default(true)
  
  // Metadata
  metadataURI   String?  // IPFS URI
  imageURL      String?  // Display image
  
  // Relationships
  holders       CharacterHolder[]
  appearances   CharacterSBTAppearance[]
  
  @@index([onChainId])
  @@index([mintingOpen])
  @@map("character_sbts")
}

model CharacterHolder {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Holder info
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  characterSBTId String
  characterSBT  CharacterSBT @relation(fields: [characterSBTId], references: [id], onDelete: Cascade)
  
  // Blockchain
  tokenId       Int?     // NFT token ID
  
  // Earnings tracking
  claimedEarnings Decimal @default(0) @db.Decimal(20, 6) // USDC claimed
  lastClaimDate   DateTime?
  
  // Metadata
  mintedAt      DateTime @default(now())
  mintPrice     Decimal  @db.Decimal(20, 6) // Price paid
  
  @@unique([userId, characterSBTId])
  @@index([userId])
  @@index([characterSBTId])
  @@map("character_holders")
}

model CharacterSBTAppearance {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  
  // Character
  characterSBTId String
  characterSBT  CharacterSBT @relation(fields: [characterSBTId], references: [id], onDelete: Cascade)
  
  // Chapter appearance
  chapterId     String
  chapter       Chapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)
  
  // Revenue distributed
  poolAmount    Decimal  @db.Decimal(20, 6) // Total betting pool (USDC)
  revenueShare  Decimal  @db.Decimal(20, 6) // Amount distributed (5% of pool)
  holderCount   Int      // Number of holders at time of distribution
  
  // Metadata
  importance    Int      @default(1) // 1-10 (could affect XP in future)
  
  @@unique([characterSBTId, chapterId])
  @@index([characterSBTId])
  @@index([chapterId])
  @@map("character_sbt_appearances")
}
